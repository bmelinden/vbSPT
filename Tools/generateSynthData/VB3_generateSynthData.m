function finalTraj=VB3_generateSynthData(varargin)
%% finalTraj=VB3_generateSynthData(varargin)
%
% Generates synthetic trajectory data in an E. coli like geometry (can be 
% specified within this file) based on a HMM model.
% This script uses parallel computing by default to disable it comment out the
% relevant rows (containing 'matlabpool') in this function.
% 
% Note: Currently this file saves the generated trajectories to files called 
% 'syntheticData_XX_runYY.mat', where XX and YY are an autogenerated indeces to prevent overwriting,
% in the 'generated Data' subfolder. 
% 
% options:
% 'runs'       : if given, determine how many datasets to be generated with
%               the same input parameters.
% 'singleTraj' : if given, only one trajectory will be run and directly through
%               simCell, which is much faster than via MakeTrajectories.
% 'timestep'   : should be given in [s].
% 'stepSize'   : the spatial discretization grid size. Default is 5 nm.
% 'locAccuracy': should be given in [nm]. Default = 0. It dose actually not
%               add to the diffusion constant that is set (which is the 
%               apperent diffusion) but merely removes its average
%               contribution from the apparent diffusion and then is added 
%               as a positioning uncertainty in every point. 
% 'transMat'   : the transition matrix. Should be an N*N matrix where N is 
%               the number of hidden states and the ij element gives the 
%               probability of transitioning from state i to state j during
%               one timestep. Each row should sum up to 1.
% 'transRate'  : the transition probability matrix in s^-1. Should not be
%               used in the call as transMat.
% 'occProb'    : a 1*N array with the occupancy of state 1 to N. Should sum
%               up to 1. If an empty array is given then use the steady state 
%               occupancy calculated from the transfer matrix. 
% 'Dapp'       : a 1*N array with the apparent diffusion constant in [um^/s].
% 'trajLengths': a 1*m array with the trajectory lengths for m trajectories. 
% 'cylinderLength'   : should be given in [nm]. Default value 2000 nm.
% 'cylinderRadius'   : should be given in [nm]. Default value 400 nm.
% 'parallel'    : if given use parallel computing.
%

%% copyright notice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% VB3_varyData, test inference robustness, in the vbSPT package
% =========================================================================
% 
% Copyright (C) 2013 Martin Lind√©n and Fredrik Persson
% 
% E-mail: bmelinden@gmail.com, freddie.persson@gmail.com
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This program is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or any later
% version.   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
% Public License for more details.
%
%  Additional permission under GNU GPL version 3 section 7
%  
%  If you modify this Program, or any covered work, by linking or combining it
%  with Matlab or any Matlab toolbox, the licensors of this Program grant you 
%  additional permission to convey the resulting work.
%  
% You should have received a copy of the GNU General Public License along
% with this program. If not, see <http://www.gnu.org/licenses/>.

%% Start of actual code
tgenData=tic;

VB3_license('VB3_generateSynthData')

%% Define filenames and paths
p = mfilename('fullpath');
[p, ~, ~] = fileparts(p);
resPath = [p filesep ];%'generatedData' filesep];
oldFold = cd(resPath);
cont = what;
ind = length(cont.mat)+1;
cd(oldFold);
saveMatname=sprintf('syntheticData_%02d.mat',ind);
saveLogname=[resPath sprintf('syntheticDataLog_%02d.log',ind)];

diary(saveLogname);
diary on

%% Define default geometry

CylinderL = 2000; % nm (length of cylindrical part only)
Radius = 400;  % nm    (spherical end caps, and cylinder radius)

% initiate options
timestep = 0; % [s]
stepSize = 5; %[nm]
locAccuracy = 0; %[nm]
transMat = 0; % [/timestep]
transRate = 0; % [/s]
occProb = 0;
Dapp = 0;
trajLengths = 0;

   
runs = 1;
do_steadystate = false;
do_parallel = false;
do_single = false;
do_transRate = false;
do_transMat = false;

%% Read options
if(nargin>1)        % parse options
    % argument counter
%     if runinputExists 
%         k=2;
%     else
        k=1;
%     end
    kmax=nargin;  % stopping criterion
    while(k<=kmax)
        option=varargin{k};
        if(strcmpi(option,'parallel'))
            do_parallel = true;
            k=k+1;
        elseif(strcmpi(option,'singleTraj'))
            do_single = true;
            k=k+1;
        elseif(strcmpi(option,'timestep'))
            if(~isempty(varargin{k+1}))
                timestep=varargin{k+1};
                if(~isnumeric(timestep) || timestep<=0)
                    error('VB3_synthData: timestep option must be followed by a positive number.')
                end
            end
            k=k+2;
       elseif(strcmpi(option,'stepSize'))
            if(~isempty(varargin{k+1}))
                stepSize=varargin{k+1};
                if(~isnumeric(stepSize) || stepSize<=0)
                    error('VB3_synthData: stepSize option must be followed by a positive number.')
                end
            end
            k=k+2;
        elseif(strcmpi(option,'runs'))
            if(~isempty(varargin{k+1}))
                runs=varargin{k+1};
                if(~isnumeric(runs) || runs<=0 || runs~=round(runs))
                    error('VB3_synthData: runs option must be followed by a positive integer.')
                end
            end
            k=k+2;
        elseif(strcmpi(option,'locAccuracy'))
            if(~isempty(varargin{k+1}))
                locAccuracy=varargin{k+1};
                if(~isnumeric(locAccuracy) || locAccuracy<0)
                    error('VB3_synthData: locAccuracy option must be followed by a positive number.')
                end
            end
            k=k+2;
       elseif(strcmpi(option,'cylinderLength'))
            if(~isempty(varargin{k+1}))
                CylinderL=varargin{k+1};
                if(~isnumeric(CylinderL) || CylinderL<=0)
                    error('VB3_synthData: CylinderL option must be followed by a positive number.')
                end
            end
            k=k+2;
       elseif(strcmpi(option,'cylinderRadius'))
            if(~isempty(varargin{k+1}))
                Radius=varargin{k+1};
                if(~isnumeric(Radius) || Radius<=0)
                    error('VB3_synthData: Radius option must be followed by a positive number.')
                end
            end
            k=k+2;
         elseif(strcmpi(option,'transMat'))
            if(~isempty(varargin{k+1}))
                transMat=varargin{k+1};
                do_transMat = true;
                [m, n] = size(transMat);
                temp = sum(transMat');
                if(~isnumeric(transMat) | m~=n | temp~=ones(1,m)) | do_transRate
                    error('VB3_synthData: transMat option must be followed by a square numeric matrix where the rows sum up to 1. Also cannot be used in conjunction with transRate option.')
                end
            end
            k=k+2;
         elseif(strcmpi(option,'transRate'))
            if(~isempty(varargin{k+1}))
                transRate=varargin{k+1};
                do_transRate = true;
                [m, n] = size(transRate);
                temp = sum(transRate');
                if(~isnumeric(transMat) | m~=n | temp~=zeros(1,m)) | do_transMat
                    error('VB3_synthData: transRate option must be followed by a square numeric matrix where the rows sum up to 0. Also cannot be used in conjunction with transMat option.')
                end
            end
            k=k+2;
         elseif(strcmpi(option,'occProb'))
            if(~isempty(varargin{k+1}))
                occProb=varargin{k+1};
                [m, ~] = size(occProb);
                if(~isnumeric(occProb) |  ~isempty(find(occProb<=0,1)) | m ~= 1 | abs(sum(occProb)-1)>1e-14)
                    error('VB3_synthData: occProb option must be followed by a 1*N numeric array which sums up to 1 or [].')
                end
                occProb=occProb/sum(occProb);
            else
                do_steadystate = true;
            end
            k=k+2;
        elseif(strcmpi(option,'Dapp'))
            if(~isempty(varargin{k+1}))
                Dapp=varargin{k+1};
                [m, ~] = size(occProb);
                if(~isnumeric(Dapp) | Dapp<=0 | m ~= 1 | max(Dapp) > 100)
                    error('VB3_synthData: Dapp option must be followed by a 1*N numeric array in units um^2/s.')
                end
                Dapp = Dapp*1e6;
            end
            k=k+2;
        elseif(strcmpi(option,'trajLengths'))
            if(~isempty(varargin{k+1}))
                trajLengths=varargin{k+1};
                [m, ~] = size(trajLengths);
                if(~isnumeric(trajLengths) | trajLengths<=0 | m ~= 1 | trajLengths~=round(trajLengths))
                    error('VB3_synthData: trajLengths option must be followed by a 1*N numeric integer array.')
                end
            end
            k=k+2;
        else
            error(['VB3_synthData: option ' option ' not recognized.'])
        end
    end
end

%% Check for strange values
if(timestep==0 | (~do_transMat && ~do_transRate) | sum(Dapp)==0 | sum(trajLengths)==0) 
    error('Not a valid input, either a runinputfile/struct has to be the first argument or all options must be specified.');
end

%% Convert apparent diffusion to actual diffusion to go into the simulation
diffCoeff = Dapp-locAccuracy^2/timestep;

%% Convert transition matrix to transition rates

if ~do_transRate
    ef = 0;
    try
        [transRate, ef] = logm(transMat);
        transRate = transRate./timestep;
        % take out off diagonal elements
        od = transRate(~eye(size(transRate)));
        if ef ~= 0 || ~isreal(transRate) || abs(sum(sum(transRate, 2)))>10^(-10) || ~isempty(od(od<0))
            warning(['VB3_generateSynthData: Conversion to transition rate matrix using '...
                'logm did not work properly. Using a simple 1st order approximation.']);
            transRate = transMat./timestep;
            transRate(~~eye(size(transRate))) = 0;
            transRate(~~eye(size(transRate))) = -sum(transRate, 2);
        end
    catch err
        warning(['VB3_generateSynthData: Conversion to transition rate matrix using '...
            'logm did not work properly. Using a simple 1st order approximation.']);
        disp(err.message);
        transRate = transMat./timestep;
        transRate(~~eye(size(transRate))) = 0;
        transRate(~~eye(size(transRate))) = -sum(transRate, 2);
    end
end

% Set the diagonal elements to 0 since it corresponds to 'self-transition'
transRateMod = transRate;
transRateMod(~~eye(size(transRate))) = 0;


%% Convert back to transMat (giving the true one corresponding to transRate)
transMat2 = expm(transRate.*timestep);

%% Calculate dwelltimes
dwellTimes=1./(1-diag(transMat2))';

%% Use steady state occupancy if desired
if do_steadystate
    occProb = transMat2^1000;
    occProb = occProb(1,:);
end


%% Plot the trajectory length distribution
%figure(1);
%clf
%hist(trajLengths,0:100);

%% List the parameters
format compact
runs
do_steadystate
do_parallel
do_single
CylinderL
Radius
timestep
stepSize
locAccuracy
numTraj = length(trajLengths)
avTrajLength = mean(trajLengths)
shortestTraj = min(trajLengths)
longestTraj = max(trajLengths)
Dapp
occProb
disp('Dwelltimes after converted from transRate to transMat using expm [timestep^-1]:');
dwellTimes
disp('transMat (transition probabilities) [timestep^-1]:');
transMat
disp('transRate after conversion from transMat [s^-1]:');
transRate
disp('transMat after converted back using expm (transition probabilities) [timestep^-1]:');
transMat2


%% Make the trajectories
% check if matlabpool is open, if yes close it
temp = matlabpool('size');
if temp~=0
matlabpool close
end

% start parallel computing if the option is given
if do_parallel
matlabpool open
end

for m=1:runs
    disp(['Run ' num2str(m)]);
tic    
if ~do_single
    [finalTraj, ~] = MakeTrajectories(CylinderL, Radius, diffCoeff, transRateMod, trajLengths, timestep, stepSize, locAccuracy, occProb);
else
    [~, finalTraj{1}, ~, ~] = simCell(CylinderL, Radius, diffCoeff, transRateMod, trajLengths(1), timestep, stepSize, locAccuracy, find(rand<=(cumsum(occProb./(sum(occProb)))), 1));
end
toc

cd(resPath);
if runs > 1
save([saveMatname '_run' num2str(m)]);
pause(1)
else
   save(saveMatname); 
end
cd(oldFold);
end

% close parallel computing
if do_parallel
matlabpool close
end

disp(['Finished generating synthetic data in ' num2str(toc(tgenData)/60) ' min.']);

diary off;
end
